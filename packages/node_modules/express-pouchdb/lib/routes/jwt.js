'use strict';

const utils = require('../utils');
const jwt = require('jsonwebtoken');

module.exports = function(app) {
  utils.requires(app, 'config-infrastructure');

  // check if enabled
  const authHandlers =
    app.couchConfig.get('httpd', 'authentication_handlers') || '';
  if (authHandlers.indexOf('jwt') === -1) {
    return;
  }

  async function getJwtOptions() {
    const algorithm = app.couchConfig.get('jwt', 'algorithm');
    if (!algorithm) {
      throw new Error('Missing jwt.algorithm');
    }
    const publicKey = app.couchConfig.get('jwt', 'public_key');
    if (!publicKey) {
      throw new Error('Missing jwt.public_key');
    }
    const expiresIn = app.couchConfig.get('jwt', 'expires_in');
    if (!expiresIn) {
      throw new Error('Missing jwt.expires_in');
    }
    return { algorithm, publicKey, expiresIn };
  }

  function hasAuthorizationBearer(req) {
    return (
      req.headers &&
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer ')
    );
  }

  async function extractToken(req) {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new Error('Missing authorization bearer');
    }

    return authHeader.substring(7, authHeader.length);
  }

  async function verifyPayload(token) {
    const { algorithm, publicKey } = await getJwtOptions();
    // blocking call, as inside of async function
    const decoded = jwt.verify(token, publicKey, { algorithms: [algorithm] });
    if (!decoded.userCtx) {
      throw new Error('Missing userCtx in payload');
    }
    return decoded;
  }

  async function isTokenExpired(token) {
    const { algorithm, publicKey } = await getJwtOptions();
    try {
      await jwt.verify(token, publicKey, { algorithms: [algorithm] });
    } catch (err) {
      if (err.name === 'TokenExpiredError') {
        return true;
      }
    }
    return false;
  }

  async function updateUserConfig(req, userName, configUpdate) {
    const userStateDb = new req.PouchDB(getStateName(userName));
    try {
      const userConfig = await userStateDb.get('config');
      await userStateDb.put({ ...userConfig, ...configUpdate });
    } catch (err) {
      if (err.status !== 404) {
        throw err;
      }
      await userStateDb.put({ _id: 'config', ...configUpdate });
    }
  }

  async function postHandler(req, res) {
    try {
      const { name, password } = req.body;

      const _users = await utils.getUsersDB(app, req.PouchDB);
      const resp = await _users.multiUserLogIn(name, password);
      if (req.query.next) {
        utils.setLocation(res, req.query.next);
        return res.status(302).end();
      }

      const userCtx = {
        db: getStateName(resp.name),
        name: resp.name,
        roles: resp.roles
      };
      const { publicKey, expiresIn } = await getJwtOptions();
      const accessToken = jwt.sign({ userCtx }, publicKey, { expiresIn });

      const userId = getUserId(userCtx.name);
      const _user = await _users.get(userId);
      const issuedTokens = _user.issued_tokens || [];

      // remove expired tokens
      const tokens = issuedTokens.map(
        async token => await isTokenExpired(token)
      );

      const issued_tokens = [...tokens, accessToken];

      if (issued_tokens.length > _user.allowed_connections) {
        throw new Error('Connection limit');
      }

      await _users.put({ ..._user, issued_tokens });
      await updateUserConfig(req, userCtx.name, { issued_tokens });

      // ok
      utils.sendJSON(res, 200, {
        accessToken,
        expiresIn
      });
    } catch (err) {
      utils.sendError(res, err);
      return;
    }
  }

  async function deleteHandler(req, res) {
    try {
      const token = await extractToken(req);
      const payload = await verifyPayload(token);

      // remove token
      const _users = await utils.getUsersDB(app, req.PouchDB);
      const userId = getUserId(payload.userCtx.name);
      const _user = await _users.get(userId);
      const issuedTokens = Array.isArray(_user.issued_tokens)
        ? _user.issued_tokens
        : [];

      if (issuedTokens.indexOf(token) === -1) {
        throw new Error('User is not logged in');
      }
      const issued_tokens = issuedTokens.filter(item => item !== token);

      await _users.put({ ..._user, issued_tokens });
      await updateUserConfig(req, payload.userCtx.name, { issued_tokens });

      // ok
      utils.sendJSON(res, 204);
    } catch (err) {
      utils.sendError(res, err);
      return;
    }
  }

  app.post('/_jwt', utils.jsonParser, utils.urlencodedParser, postHandler);
  app.delete('/_jwt', utils.jsonParser, utils.urlencodedParser, deleteHandler);

  app.use(async (req, res, next) => {
    try {
      if (!hasAuthorizationBearer(req)) {
        return next();
      }
      const token = await extractToken(req);
      const payload = await verifyPayload(token);
      // admin party for the whitelisted IPs
      setSession(req, { ...payload.userCtx }, next);
    } catch (err) {
      const whiteList = app.couchConfig.get('jwt', 'white_list') || '';
      if (whiteList.indexOf(req.connection.remoteAddress) === -1) {
        utils.sendError(res, err);
        return;
      }
      return setSession(req, { roles: ['_admin'] }, next);
    }
  });
};

function setSession(req, userCtx, next) {
  if (!userCtx.roles) {
    userCtx.roles = [];
  }
  req.couchSession = {
    ok: true,
    userCtx,
    authenticated: 'jwt'
  };
  return next();
}

function getStateName(name) {
  return `state_${name}`;
}

function getUserId(name) {
  return `org.couchdb.user:${name}`;
}
